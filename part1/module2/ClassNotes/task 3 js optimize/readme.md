
性能优化

概要 summary
1. 内存管理
2. 垃圾回收与常见的GC算法
3. V8 引擎的垃圾回收
4. Performance 工具
5. 代码优化示例


//---------------------------------------------------------------

内存管理

内存：由可读写的单元组成，表示一片可操作的空间
管理：人为管理的一片空间的申请，使用和释放
内存管理：开发者主动申请，使用和释放空间
管理流程：申请-使用-释放


//---------------------------------------------------------------

垃圾回收

js中的内存管理是自动的
如何判断一个对象是否成为垃圾？
1.当一个对象不再引用的时候
2.当一个对象无法从根上访问的时候

js 中的可达对象：
1.可以访问到的对象就是可达对象（引用，作用域链）
2.可达的标准就是从根出发是否能够被找到
3.js中的根就是可以理解为全局变量对象


GC的定义与作用
1.GC就是垃圾回收机制的简称(garbage collection)
2.GC可以找到内存中的垃圾，释放并回收空间

GC中的垃圾是什么？
1.程序中不再需要使用的对象
function foo (){
  name = 'lg'
  return `${name} is a coder`
}
foo()
2.程序中不能再访问到的对象
function foo () {
  const name = 'lg'
  return `${name} is a coder`
}
foo()


GC算法是什么？
1.是一种机制，垃圾回收器完成工作
2.工作的内容是查找，释放和回收空间
3.算法就是查找和回收所遵循的规则

常见的GC算法？
引用计数
标记清楚
标记整理
分代回收


//----------------------------------------------------------

引用计数算法实现原理：
核心思想：设置引用数，判断当前的引用数是否是0
引用计数器
引用关系改变时修改引用数
当引用数为 0 时立即回收

引用计数的优点：
1.发现垃圾时立即回收
2.最大限度减少程序暂停，因为总是及时清理垃圾

引用计数的缺点：
1.无法回收循环引用的对象
2.时间开销太大

//---------------------------------------------------------

标记清除算法的实现原理
主要是标记和清除两个阶段
1.遍历所有对象标记活动的对象
2.遍历素有的对象清除未标记的对象
回收对应空间

优点：
循环引用可以清除，函数作用域内的两个相互引用的局部变量会被清除，
因为是不可达的对象，从根（global）出发

缺点：
空间碎片化问题，怎么理解呢？
其实就是释放的对象空间地址是不连续的，所以就是一片一片的，好多碎片，
释放的空间在空闲链表里，别人申请空间的时候，总是难以完美匹配，比如我申请1500kb
可是你只有1000kb和2000kb的空闲空间，那我就很尴尬，无法使空闲空间达到最大化的使用

//------------------------------------------------------------------------

标记整理算法原理
和标记清除类似，使增强版的标记清除
分标记和清除两个阶段
1.遍历所有对象标记活动对象
2.清除阶段会执行整理，移动对象的位置，使之连续

//------------------------------------------------------------------------

V8 引擎，分代回收
内存分为新生代和老生代
针对不同对象采用不同算法

V8中常用的GC算法
1.分代回收
2.空间复制
3.标记清除
4.标记整理
5.标记增量

//------------------------------------------------------------------------
V8 如何回收新生代对象？

v8的内存分配：
v8内存空间一分为二
小空间用于存储新生代对象（32M/16M）
新生代指的是存活时间较短的对象（比如某些局部作用域里的对象，执行完以后就要释放回收）

新生代对象回收实现：
回收过程是复制算法 + 标记整理
新生代内存区分为两个等大的空间 from 和 to
使用空间为from状态 空闲空间为to状态
活动对象存储于from空间
标记整理后再将活动对象拷贝到 to，相当于是有了备份
from 与 to 交换空间，完成原from的释放

回收细节说明：
拷贝的过程中会出现晋升
晋升就是将新生代对象移动至老生代
1.一轮GC过后，还存活的新生代需要晋升
2.to 空间的使用率超过25%，也需要将这些对象晋升，主要是为了交换以后，给 from 留足够的空间

//------------------------------------------------------------------------
V8如何回收老生代区？

64位操作系统1.4G，32位700M
老生代区的对象是存活时间较长的，比如全局变量，闭包里的变量

如何实现：
1.主流策略还是标记清除回收垃圾，因为不用整理的话效率还是很高的
2.遇到一种情况，就是新生代区要拷贝一些对象到老生代区，而且老生代区内存不太够的时候，就用到标记整理
3.采用增量标记进行优化

细节对比：
新生代区空间不是很大，所以用空间换时间，还是划的来
老生代区空间大，不适合复制算法，既浪费空间又浪费时间


标记增量如何实现？
1.程序执行分匹执行，先执行一部分，停下来；
2.遍历对象进行标记
3.再执行程序一会儿，停
4.再标记
...
5.直到标记完后，需要完成清除，这时程序停止，开始清除垃圾
6.清除完，执行程序

如果不适用标记增量是啥效果？
程序执行完，会暂停很长时间进行垃圾回收，再继续执行；

其实就是执行程序和标记对象交替进行；

//--------------------------------------------------------------------
V8 总结

主流js执行引擎
内存设置上限（浏览器够用就行；如果内存太大，垃圾回收的时候可能体验不好）
分代回收思想做垃圾回收
内存分为新生代老生代
V8回收常见的GC算法


//---------------------------------------------------------------------
performance 工具实时监控内存


内存的外在表现：
1.页面出现延迟加载或经常性暂停
2.页面持续性出现糟糕性能
3.页面的性能随时间延长越来越差


界定内存问题的标准:
1.内存泄漏，内存使用持续升高
2.内存膨胀，在多数设备上存在性能问题
3.频繁的垃圾回收，通过内存变化图进行分析


监控内存的几种方式:
浏览器任务管理器
Timeline时序图记录
堆快照查找分离DOM
判断是否存在频繁的垃圾回收


1. 任务管理器监控内存：
shift + esc 调出任务管理器
观察内存和js内存
内存：dom结点占用的内存
js内存：界面中所有可达的活动对象占用的内存(小括号里的)

只能简单观察是否变大，是否稳定不变，若变大说明不断的生成新对象
无法定位问题

2. Timeline记录内存
借助浏览器的性能工具录制查看

3. 堆快照查找分离DOM

什么是分离DOM？
界面元素存活在DOM树上
垃圾对象时的DOM节点
分离状态的DOM节点

垃圾：一个dom节点从树上分离，并且js中没有引用
分离dom：只是从树上分离，但是js中还有引用

借助浏览器工具内存选项快照功能，查找是否有detach元素，
不在tree上却被js引用的dom对象

4. 为什么要确定频繁的GC
GC工作时应用程序时停止的
频繁且过长的GC会导致程序假死
用户使用中感知应用卡顿

如何确定？
timeline中频繁的上升下降
任务管理旗中数据频繁的增加或者减小


//--------------------------------------------------------------------------------
如何精准的测试js的性能？
1.本质上就是采集大量的执行样本进行数学统计和分析
2.使用基于 Benchmark.js 的 https://jsperf.com/ 完成

Jsperf 使用流程
1.使用github账号登录
2.填写个人信息（非必须）
3.填写详细的测试用例信息title slug
4.填写准备代码（dom操作时经常使用）
5.填写必要有setup与teardown代码
6.填写测试代码片段



//--------------------------------------------------------------------------------
一 慎用全局变量

原因：
1.全局变量定义在全局执行上下文，是所有作用域链的顶端
2.全局执行上下文一直存在于上下文执行栈，直到程序退出
3.如果某个局部作用域出现了同名变量则会遮蔽或污染全局

可以写代码在jsperf上测试，不过好像不能用了



二 缓存全局变量

示例：

function getBtn (){
  const btn1 = document.getElementById('btn1')
  const btn2 = document.getElementById('btn2')
  const btn3 = document.getElementById('btn3')
  const btn4 = document.getElementById('btn4')
}

优化后 对 document 进行了缓存，效率高了一些
function getBtn1 (){
  const obj = document
  const btn1 = obj.getElementById('btn1')
  const btn2 = obj.getElementById('btn2')
  const btn3 = obj.getElementById('btn3')
  const btn4 = obj.getElementById('btn4')
}



三 通过原型对象添加附加方法

function fn1 (){
  this.foo = function (){
    console.log(11111);
  }
}

const fn1 = new fn1()


// 原型链定义函数 效率高
function fn2 (){
 
}
fn2.prototype.foo = function (){
  console.log(11111);
}

const fn2 = new fn2()



四 避开闭包陷阱

闭包特点：
外部具有指向内部的引用
在外部作用域访问内部作用域的数据

关于闭包：
闭包是一种强大的语法
闭包使用不当很容易出现内存泄漏
不要为了闭包而闭包

示例
function foo1(){
  let el = document.getElementById('btn')
  el.onclick = function () {
    console.log(this);
    console.log(el.id);
  }
  // el = null // 不用的时候 null 去除内存泄漏
}
foo1()



五 避免属性访问方法使用
js 不需要属性访问方法，所有属性外部都可见
使用属性访问方法只会增加一层重定义，没有控制能力

function Person () {
  this.name = 'hanfei'
  this.getName = function(){
    return this.name
  }
}

const p1 = new Person()
const name1 = p1.getName()

// 直接放属性即可 效率更高
function Person2 (){
  this.name = 'hanfei'
}

const p2 = new Person2()
const name2 = p2.name



六 For循环优化
const arr = [...] 100个
// 直接写法
<!-- for (let i=0;i<arr.length;i++){} -->
// 优化写法 效率更高
<!-- for (let i=0,len = arr.length;i<len;i++){} -->


七 选择最优的循环方式
forEach 最快
普通 for 次快
forin 最慢



八 文档碎片优化节点添加
 // 优化
    const flag = document.createDocumentFragment()
    for (let i = 0; i < 10; i++) {
      const p = document.createElement('p')
      p.innerHTML = i
      flag.appendChild(p)
    }
    document.body.appendChild(flag)
用片段对象来存储



九 克隆优化节点操作
// 旧方法
    for (let i = 0; i < 10; i++) {
      const p = document.createElement('p')
      p.innerHTML = i
      document.body.appendChild(p)
    }


    // 优化 克隆
    const old = document.getElementById('p1')
    for (let i = 0; i < 10; i++) {
      const newp = old.cloneNode(false)
      newp.innerHTML = i
      document.body.appendChild(p)
    }



十 直接量替换

// 更快
const arr = [1,2,3]

// 慢
const arr = new Array(3)
arr[0] = 1
arr[1] = 2
arr[2] = 3


