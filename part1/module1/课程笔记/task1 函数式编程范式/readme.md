函数式编程 
编程范式之一 （还有面向过程 面向对象）
概念：把现实世界的事物和事物之间的联系抽象到程序世界（对运算过程进行抽象）

函数式编程中的函数指的不是程序中的函数(方法)，而是数学中的函数即映射关系，例如：y = sin(x)，x和y的关系

纯函数
相同的输入始终都要要有相同的输出

1. 高阶函数的意义
用来抽象通用问题，屏蔽细节
比如：一个数组的 for 循环可以直接封装一个函数叫 forEach 来解决，具体的循环不需要自己再手动重复实现；
再比如： 一个数组的 filter 过滤函数，当中的 for 循环其实也是通用的，不通用的是过滤条件，所以通用部分也可以直接封装进一个函数；

这部分要参考高阶函数的代码



2. 闭包
（closure）函数和其周围的状态（词法环境）的引用捆绑到了一起形成了闭包
实现场景：
1.可以在另一个作用域中，调用一个函数的内部函数并且还可以访问该函数的作用域中的成员
比如：函数作为返回值的例子

闭包的本质：函数在执行的时候会放到一个执行栈上，当函数执行完毕的时候会从执行栈上移除；但是堆上的作用域成员因为被外部引用而不能被释放，
因此内部函数依然可以访问外部函数的成员



3. 纯函数
概念：相同的输入一定会有相同的输出，类似数学函数
Lodash 一个工具库 比如 操作数组 first find includes last 

好处：
1. 可缓存，因为纯函数是相同的输入一定有相同的输出，所以可以将返回值缓存，技术就是记忆函数 memoize
2. 可测试，
3. 并行处理： 多线程环境下，并行操作内存共享的数据可能会出现以外情况；纯函数不需要访问内存中的共享数据，所以在并行环境下可以任意使用纯函数（web worker）



4. 副作用：副作用就是有一些外部变量或者外部交互导致一个函数变得不纯，如果一个函数依赖于外部得状态，那就无法保证输出结果不变。
比如下面这段代码：

let mini = 18;
function func (age) {
  return age > mini
}
全局变量 mini 若被修改，func 结果就不一定了。

如何变纯？
function func (age) {
  let mini = 18; 
  return age > mini
}
这就产生了一个硬编码问题 let mini = 18 可以用柯里化解决


副作用来源：配置文件，数据库，用户输入等等

所有的外部交互都有可能带来副作用，使得方法得通用性下降不适合扩展和重用，还会给程序带来一定得安全隐患，不能完全避免，但要尽量可控。



5. 柯里化 currying
一个函数有多个参数，先传递一部分参数来调用，这部分参数永远不会变；
返回一个新函数接受剩余参数；

5.1 柯里化函数：
_.curry(func)
功能：创建一个函数，该函数接受一个或者多个 func 得参数，如果 func 所需要得参数都被提供执行，那就返回结果；
否则就返回函数等待接受剩余得参数；参考代码
参数： 需要柯里化得函数
返回值： 柯里化后得函数
最大得作用就是多元函数转一元函数

5.2 自定义柯里化函数： 闭包 + 递归 + 合并参数
主要思路：
1. 返回一个有名字得函数，比如 curried
2. 在这个函数里判断参数个数是否大于等于被柯里化得函数得参数个数 length ; 
2.1 大于等于就直接调用函数了；
2.2 小于就返回一个匿名函数，匿名函数返回 调用curried 函数，并把所有参数合并传入

合并参数这一部分： es6 写法： ...args1,...args2
也可以这么写 ...args.concat(Array.from(arguments))

总结：
1. 柯里化可以让我们给一个函数传递较少参数，然后返回一个已经包含了固定参数得新函数
2. 这是一种对函数参数得缓存
3. 让函数变灵活，让函数得粒度更小
4. 可以把多元函数转成一元函数，可以组合函数产生强大得功能



6. 函数组合
纯函数和柯里化很容易写出洋葱代码h(g(f(v)))
函数组合可以让细粒度得函数们组合成一个新函数
如果一个函数需要经过多个函数处理才能得到最终值，这个函数可以把中间得多个函数合并成一个函数；
函数就像是数据得管道，函数组合就是把管道都连接起来，让数据穿过多个管道形成最终结果
函数组合默认是从右往左执行得

6.1 函数组合满足结合律 associativity

let f = compose(f, g, h)
我们既可以把 f 和 g 先组合，也可以把 g 和 h 先组合，结果一致


6.2 lodash fp 模块
fp 提供了已经自动柯里化得函数，原则就是函数优先，数据置后

// 常规函数
_.map(['a','b','c','d'], _.toUpper)  // ['A','B','C','D']

// fp得函数
fp.map(fp.toUpper, ['a','b','c','d'])
fp.map(fp.toUpper)(['a','b','c','d'])



7. Point Free ：我们可以把数据处理得过程定义成与数据无关得合成运算，不需要代表数据得那个参数，
只需要把简单得运算步骤合成到一起，在使用这种模式之前我们需要定义一些辅助得基本函数。

不需要指明处理得数据
只需要合成运算过程
需要定义一些辅助得基本运算函数



8. 函子 functor

作用：把副作用控制在可控得范围内

什么是Functor ？
容器：包含值和值得变形关系（变形关系就是函数）
函子：一个特殊得容器，通过一个普通对象来实现，该对象具有 map 方法，map 方法可以运行一个函数对值进行处理

总结：
1. 函数式编程得运算不直接操作值，而是由函子完成
2. 函子就是实现了一个 map 锲约得对象
3. 函子就是一个盒子，封装了一个值
4. 想要处理盒子中得值，我们就需要给 map 方法传递一个纯函数，由这个函数来处理
5. 最终 map 方法返回一个包含新值得函子

缺陷：无法处理传入 null 和 undefined 带来得副作用


8.1 MayBe 函子
编程过程中可能会遇到很多错误，需要对这些错误做相应得处理
MayBe 函子得作用可以对外部得空值情况做处理 控制副作用在允许范围内

缺陷：链式 map 中传入 null 得时机无法判断


8.2 Either 函子
Either 两者中得任何一个，类似 if...else...
异常会让函数变得不纯，而 Either 函子可以用来做异常处理


8.3 IO 函子
IO 函子中得_value是一个函数，这里把函数当作值来处理
可以把不纯得动作存储到_value里，延迟执行不纯得操作（惰性执行），保证当前得操作是纯得
把不纯得操作给调用者来执行


8.4 task 异步执行
用 folktale 中得 task 来演示；

folktale 一个标准得函数式编程库
与 ladash 和 ramda 不同得是 没有提供很多功能函数
只提供了一些函数式处理得操作，例如 compose，curry等，一些函子 Task Either MayBe 等


8.5 pointed 函子
实现了of 静态方法得函子
表层含义避免使用 new 来创建对象
深层含义of方法用来把值放到上下文中context（把值放到容器中，使用map来处理）

 class Container {
    static of(v) {
      return new Container(v)
    }
 }

 const r = Container.of(5)
   .map(x => x + 1)



8.6 Monad 函子
可以变扁得 Pointed 函子，IO(IO())
一个函子如果具有 join 和 of 两个方法并遵守一些定律就是一个 Monad 



 

